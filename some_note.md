## 总结
对于本次项目的实践,算是有三方面的收获.
1. 理论方面深化了对于不同平台动态库的理解.
2. 实践方面算是实现了一个较为完美的程序只启动一次进程的效果.
3. 语言方面对 `extern "C"` 和 `__declspec(dllexport)` 的理解更深入.

### 动态库的差异性
这里就不展开细讲了,只给出比较关键性的结论,如果需要详细了解,建议读《程序员的自我修养 链接 装载和库》.

* 共性:Windows和Linux都需要在程序启动的时候装载对应的动态库.
* 不同:两者对于动态库中符号地址的查找或者说装载方式是不一样的,Windows是根据需要使用的符号的地址动态的把源数据拷贝到当前进程的地址空间,而Linux采用地址无关代码在程序运行的时候动态的计算并查找对应的符号地址,而对于动态中的导出变量则是采取COW的技术,也就是说Linux动态库牺牲了些许性能,但有利于内存,Windows则是牺牲了内存有利于性能.

### Why extern "C"?
我们可以把动态库的加载分为两种:
1. 显式加载:在具体的 `C/C++` 代码中通过不同操作系统提供的调用来加载对应的动态库(比如 `dlopen` ),然后再通过其他系统调用来根据符号获得对应的指针(比如 `dlsym`),这种加载方式的灵活性非常高,不仅可以再 `C/C++` 中完成这一操作,还能使用其他语言来调用,也就是完成了 `C/C++` 的跨语言交互.
2. 隐式加载:不需要在代码中额外做任何的加载动作,你只需要让这个动态库参与编译时链接即可(编译时链接是在编译程序时将程序和动态库的符号解析并绑定在一起),然后确保在运行时链接动态库能够被找到,这个用法和静态库类似,不一样的是静态库只需要进行编译时链接,且参与链接后代码和数据是完整的被复制到了最终的可执行程序中.

这两种链接的方式和我要讲的 `extern "C"` 又有什么关系?

经过对上述文字的理解,我们了解到显式加载需要通过对应的符号名称(函数名)来调用动态库中的函数.
而隐式加载只需要提供的头文件,根据头文件的声明直接调用对应函数即可,具体的符号翻译过程编译器在编译过程中已经帮我们做了.

那么重点来了,在显式加载后,我们如何确定符号的名称?其实在C++中函数名和他最终编译生成的符号名是完全不一样的,这是因为需要支持函数重载和命名空间等特性.而C的符号完全和代码中的变量名或函数名是完全一致的.

`extern "C"` 的作用其实只有一个:让编译器把代码按照 `C` 的方式去编译,则最终的函数符号和它的函数名是完全一致的,那么我们作为动态库的使用者就能够正常的通过显式加载来调用对应的函数了.

所以你会在很多需要被跨语言调用的C++代码中见到 extern "C" 这个东西.
### Why __declspec(dllexport)?
* 从使用的角度来看:Windows的动态库所有符号默认是不导出的(还是得看使用的动态链接器,比如mingw的动态链接器也是默认全都导出的),需要显式的通过 `__declspec(dllexport)` 来导出.
* 从这么设计的原因来看:前面提到了Windows需要在运行期间动态的替换使用到的动态库符号地址并把对应的数据拷贝到当前的进程空间中,如果默认全都导出那么将会导致全部都拷贝,而如果按需进行导出将会节省这个加载的内存消耗.


